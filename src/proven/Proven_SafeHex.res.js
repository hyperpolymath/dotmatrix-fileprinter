// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "@rescript/runtime/lib/es6/Belt_Array.js";

let hexChars = "0123456789abcdef";

let hexCharsUpper = "0123456789ABCDEF";

function hexCharToInt(char) {
  let code = char.charCodeAt(0) | 0;
  if (code >= 48 && code <= 57) {
    return code - 48 | 0;
  } else if (code >= 65 && code <= 70) {
    return code - 55 | 0;
  } else if (code >= 97 && code <= 102) {
    return code - 87 | 0;
  } else {
    return;
  }
}

function intToHexChar(value) {
  if (value >= 0 && value <= 15) {
    return hexChars.charAt(value);
  }
}

function encode(bytes) {
  if (bytes.length === 0) {
    return {
      TAG: "Ok",
      _0: ""
    };
  }
  let result = {
    contents: ""
  };
  let valid = {
    contents: true
  };
  Belt_Array.forEach(bytes, byte => {
    if (!(valid.contents && byte >= 0 && byte <= 255)) {
      valid.contents = false;
      return;
    }
    let high = (byte >>> 4);
    let low = byte & 15;
    result.contents = result.contents + hexChars.charAt(high) + hexChars.charAt(low);
  });
  if (valid.contents) {
    return {
      TAG: "Ok",
      _0: result.contents
    };
  } else {
    return {
      TAG: "Error",
      _0: "InvalidCharacter"
    };
  }
}

function encodeUppercase(bytes) {
  if (bytes.length === 0) {
    return {
      TAG: "Ok",
      _0: ""
    };
  }
  let result = {
    contents: ""
  };
  let valid = {
    contents: true
  };
  Belt_Array.forEach(bytes, byte => {
    if (!(valid.contents && byte >= 0 && byte <= 255)) {
      valid.contents = false;
      return;
    }
    let high = (byte >>> 4);
    let low = byte & 15;
    result.contents = result.contents + hexCharsUpper.charAt(high) + hexCharsUpper.charAt(low);
  });
  if (valid.contents) {
    return {
      TAG: "Ok",
      _0: result.contents
    };
  } else {
    return {
      TAG: "Error",
      _0: "InvalidCharacter"
    };
  }
}

function encodeString(input) {
  let result = "";
  for (let i = 0, i_finish = input.length; i < i_finish; ++i) {
    let code = input.charCodeAt(i) | 0;
    if (code <= 255) {
      let high = (code >>> 4);
      let low = code & 15;
      result = result + hexChars.charAt(high) + hexChars.charAt(low);
    } else {
      let highByte = (code >>> 8);
      let highHigh = (highByte >>> 4);
      let highLow = highByte & 15;
      result = result + hexChars.charAt(highHigh) + hexChars.charAt(highLow);
      let lowByte = code & 255;
      let lowHigh = (lowByte >>> 4);
      let lowLow = lowByte & 15;
      result = result + hexChars.charAt(lowHigh) + hexChars.charAt(lowLow);
    }
  }
  return result;
}

function decode(hexStr) {
  let normalized = hexStr.trim().toLowerCase();
  let length = normalized.length;
  if (length === 0) {
    return {
      TAG: "Ok",
      _0: []
    };
  }
  if (length % 2 !== 0) {
    return {
      TAG: "Error",
      _0: "InvalidLength"
    };
  }
  let numBytes = length / 2 | 0;
  let bytes = Belt_Array.make(numBytes, 0);
  let valid = true;
  let errorType = "InvalidCharacter";
  for (let i = 0; i < numBytes; ++i) {
    if (valid) {
      let highChar = normalized.charAt((i << 1));
      let lowChar = normalized.charAt((i << 1) + 1 | 0);
      let match = hexCharToInt(highChar);
      let match$1 = hexCharToInt(lowChar);
      if (match !== undefined && match$1 !== undefined) {
        bytes[i] = (match << 4) + match$1 | 0;
      } else {
        valid = false;
        errorType = "InvalidCharacter";
      }
    }
  }
  if (valid) {
    return {
      TAG: "Ok",
      _0: bytes
    };
  } else {
    return {
      TAG: "Error",
      _0: errorType
    };
  }
}

function decodeToString(hexStr) {
  let e = decode(hexStr);
  if (e.TAG !== "Ok") {
    return {
      TAG: "Error",
      _0: e._0
    };
  }
  let result = {
    contents: ""
  };
  Belt_Array.forEach(e._0, byte => {
    result.contents = result.contents + String.fromCharCode(byte);
  });
  return {
    TAG: "Ok",
    _0: result.contents
  };
}

function isValidHex(hexStr) {
  let trimmed = hexStr.trim();
  let length = trimmed.length;
  if (length === 0 || length % 2 !== 0) {
    return false;
  } else {
    return /^[0-9a-fA-F]+$/.test(trimmed);
  }
}

function constantTimeEqual(hexA, hexB) {
  let normalizedA = hexA.trim().toLowerCase();
  let normalizedB = hexB.trim().toLowerCase();
  let lengthA = normalizedA.length;
  let lengthB = normalizedB.length;
  let lengthMatch = lengthA === lengthB;
  let maxLength = lengthA > lengthB ? lengthA : lengthB;
  let diff = 0;
  for (let i = 0; i < maxLength; ++i) {
    let charA = i < lengthA ? normalizedA.charCodeAt(i) | 0 : 0;
    let charB = i < lengthB ? normalizedB.charCodeAt(i) | 0 : 0;
    diff = diff | charA ^ charB;
  }
  if (lengthMatch) {
    return diff === 0;
  } else {
    return false;
  }
}

function constantTimeEqualBytes(bytesA, bytesB) {
  let lengthA = bytesA.length;
  let lengthB = bytesB.length;
  let lengthMatch = lengthA === lengthB;
  let maxLength = lengthA > lengthB ? lengthA : lengthB;
  let diff = 0;
  for (let i = 0; i < maxLength; ++i) {
    let byteA = i < lengthA ? bytesA[i] : 0;
    let byteB = i < lengthB ? bytesB[i] : 0;
    diff = diff | byteA ^ byteB;
  }
  if (lengthMatch) {
    return diff === 0;
  } else {
    return false;
  }
}

function toLowercase(hexStr) {
  if (!isValidHex(hexStr) && hexStr.trim().length > 0) {
    return {
      TAG: "Error",
      _0: "InvalidCharacter"
    };
  } else {
    return {
      TAG: "Ok",
      _0: hexStr.trim().toLowerCase()
    };
  }
}

function toUppercase(hexStr) {
  if (!isValidHex(hexStr) && hexStr.trim().length > 0) {
    return {
      TAG: "Error",
      _0: "InvalidCharacter"
    };
  } else {
    return {
      TAG: "Ok",
      _0: hexStr.trim().toUpperCase()
    };
  }
}

function byteLength(hexStr) {
  let trimmed = hexStr.trim();
  let length = trimmed.length;
  if (length === 0) {
    return {
      TAG: "Ok",
      _0: 0
    };
  } else if (length % 2 !== 0) {
    return {
      TAG: "Error",
      _0: "InvalidLength"
    };
  } else if (isValidHex(trimmed)) {
    return {
      TAG: "Ok",
      _0: length / 2 | 0
    };
  } else {
    return {
      TAG: "Error",
      _0: "InvalidCharacter"
    };
  }
}

function padToByteLength(hexStr, targetByteLength) {
  if (targetByteLength < 0) {
    return {
      TAG: "Error",
      _0: "InvalidLength"
    };
  }
  let e = decode(hexStr);
  if (e.TAG !== "Ok") {
    return {
      TAG: "Error",
      _0: e._0
    };
  }
  let bytes = e._0;
  let currentLength = bytes.length;
  if (currentLength > targetByteLength) {
    return {
      TAG: "Error",
      _0: "InvalidLength"
    };
  }
  let padding = Belt_Array.make(targetByteLength - currentLength | 0, 0);
  return encode(Belt_Array.concat(padding, bytes));
}

function xorHex(hexA, hexB) {
  let match = decode(hexA);
  let match$1 = decode(hexB);
  if (match.TAG !== "Ok") {
    return {
      TAG: "Error",
      _0: match._0
    };
  }
  let bytesA = match._0;
  if (match$1.TAG !== "Ok") {
    return {
      TAG: "Error",
      _0: match$1._0
    };
  }
  let bytesB = match$1._0;
  if (bytesA.length !== bytesB.length) {
    return {
      TAG: "Error",
      _0: "InvalidLength"
    };
  } else {
    return encode(Belt_Array.mapWithIndex(bytesA, (i, byteA) => {
      let byteB = bytesB[i];
      return byteA ^ byteB;
    }));
  }
}

function encodeSpaced(bytes) {
  if (bytes.length === 0) {
    return {
      TAG: "Ok",
      _0: ""
    };
  }
  let parts = {
    contents: []
  };
  let valid = {
    contents: true
  };
  Belt_Array.forEach(bytes, byte => {
    if (!(valid.contents && byte >= 0 && byte <= 255)) {
      valid.contents = false;
      return;
    }
    let high = (byte >>> 4);
    let low = byte & 15;
    let hex = hexChars.charAt(high) + hexChars.charAt(low);
    parts.contents = Belt_Array.concat(parts.contents, [hex]);
  });
  if (valid.contents) {
    return {
      TAG: "Ok",
      _0: parts.contents.join(" ")
    };
  } else {
    return {
      TAG: "Error",
      _0: "InvalidCharacter"
    };
  }
}

function encodeSpacedUppercase(bytes) {
  if (bytes.length === 0) {
    return {
      TAG: "Ok",
      _0: ""
    };
  }
  let parts = {
    contents: []
  };
  let valid = {
    contents: true
  };
  Belt_Array.forEach(bytes, byte => {
    if (!(valid.contents && byte >= 0 && byte <= 255)) {
      valid.contents = false;
      return;
    }
    let high = (byte >>> 4);
    let low = byte & 15;
    let hex = hexCharsUpper.charAt(high) + hexCharsUpper.charAt(low);
    parts.contents = Belt_Array.concat(parts.contents, [hex]);
  });
  if (valid.contents) {
    return {
      TAG: "Ok",
      _0: parts.contents.join(" ")
    };
  } else {
    return {
      TAG: "Error",
      _0: "InvalidCharacter"
    };
  }
}

export {
  hexChars,
  hexCharsUpper,
  hexCharToInt,
  intToHexChar,
  encode,
  encodeUppercase,
  encodeString,
  decode,
  decodeToString,
  isValidHex,
  constantTimeEqual,
  constantTimeEqualBytes,
  toLowercase,
  toUppercase,
  byteLength,
  padToByteLength,
  xorHex,
  encodeSpaced,
  encodeSpacedUppercase,
}
/* No side effect */
