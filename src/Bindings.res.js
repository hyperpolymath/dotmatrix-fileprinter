// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Types from "./Types.res.js";
import * as Core__Array from "@rescript/core/src/Core__Array.res.js";
import * as Core__Option from "@rescript/core/src/Core__Option.res.js";
import * as Proven_SafeHex from "./proven/Proven_SafeHex.res.js";
import * as Proven_SafeMath from "./proven/Proven_SafeMath.res.js";
import * as Proven_SafePath from "./proven/Proven_SafePath.res.js";
import * as Proven_SafeString from "./proven/Proven_SafeString.res.js";
import * as Core from "@tauri-apps/api/core";

function checkGforth() {
  return Core.invoke("check_gforth", undefined);
}

function previewStrike(bytes) {
  return Core.invoke("preview_forth_strike", {
    bytes: bytes
  });
}

let rejectWithMessage = (function(msg) { return Promise.reject(new Error(msg)); });

function executeStrike(bytes, path) {
  if (Proven_SafePath.isSafe(path)) {
    return Core.invoke("execute_forth_strike", {
      bytes: bytes,
      path: path
    });
  } else {
    return rejectWithMessage("Invalid path: contains traversal sequences");
  }
}

function verifySubstrate(path) {
  if (Proven_SafePath.isSafe(path)) {
    return Core.invoke("verify_substrate", {
      path: path
    });
  } else {
    return rejectWithMessage("Invalid path: contains traversal sequences");
  }
}

function stringToBytes(str) {
  let bytes = Proven_SafeString.toCodePoints(str);
  if (bytes.TAG === "Ok") {
    return bytes._0;
  } else {
    return [];
  }
}

function bytesToString(bytes) {
  let str = Proven_SafeString.fromCodePoints(bytes);
  if (str.TAG === "Ok") {
    return str._0;
  } else {
    return "";
  }
}

function isValidByte(byte) {
  return Types.Constraints.isValidByte(byte);
}

let isValidPath = Proven_SafePath.isSafe;

function parseByteString(str) {
  let parts = str.trim().split(",").map(prim => prim.trim()).filter(s => s.length > 0);
  let bytes = parts.map(Proven_SafeMath.fromString);
  if (bytes.some(Core__Option.isNone)) {
    return {
      TAG: "Error",
      _0: "Invalid byte value"
    };
  }
  let values = Core__Array.filterMap(bytes, x => x);
  let invalid = values.findIndex(b => !Types.Constraints.isValidByte(b));
  if (invalid >= 0) {
    return {
      TAG: "Error",
      _0: `Byte at position ` + invalid.toString() + ` is invalid`
    };
  } else {
    return {
      TAG: "Ok",
      _0: values
    };
  }
}

function bytesToHex(bytes) {
  let hex = Proven_SafeHex.encodeSpaced(bytes);
  if (hex.TAG === "Ok") {
    return hex._0;
  } else {
    return "";
  }
}

function bytesToHexCompact(bytes) {
  let hex = Proven_SafeHex.encode(bytes);
  if (hex.TAG === "Ok") {
    return hex._0;
  } else {
    return "";
  }
}

function hexToBytes(hexStr) {
  let bytes = Proven_SafeHex.decode(hexStr);
  if (bytes.TAG === "Ok") {
    return {
      TAG: "Ok",
      _0: bytes._0
    };
  }
  switch (bytes._0) {
    case "InvalidLength" :
      return {
        TAG: "Error",
        _0: "Invalid hex length (must be even)"
      };
    case "InvalidCharacter" :
      return {
        TAG: "Error",
        _0: "Invalid hex character"
      };
    case "EmptyInput" :
      return {
        TAG: "Ok",
        _0: []
      };
  }
}

export {
  checkGforth,
  previewStrike,
  rejectWithMessage,
  executeStrike,
  verifySubstrate,
  stringToBytes,
  bytesToString,
  isValidByte,
  isValidPath,
  parseByteString,
  bytesToHex,
  bytesToHexCompact,
  hexToBytes,
}
/* @tauri-apps/api/core Not a pure module */
